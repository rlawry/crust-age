<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Seafloor Age – Interactive Viewer</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: #000;
        }

        body {
            font-family: system-ui, sans-serif;
            color: #fff;
        }

        #container {
            position: relative;
            width: min(90vw, 1200px);
            aspect-ratio: 90 / 80;
            margin: 20px auto;
        }

        #ageCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #111;
            cursor: crosshair;
        }

        /* overlays pinned to viewport */

        #instructions {
            position: fixed;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 13px;
            pointer-events: none;
            white-space: nowrap;
        }

        /* region selector, under instructions */
        #regionBar {
            position: fixed;
            top: 34px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        #regionBar select {
            font-size: 13px;
            background: #222;
            color: #fff;
            border-radius: 4px;
            border: 1px solid #555;
            padding: 2px 6px;
        }

        #info {
            position: fixed;
            left: 10px;
            top: 70px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            font-size: 13px;
            border-radius: 4px;
            pointer-events: none;
            white-space: nowrap;
        }

        #legend {
            position: absolute;
            right: 10px;
            bottom: 10px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            font-size: 12px;
            border-radius: 4px;
        }

        #legendBar {
            width: 200px;
            height: 12px;
            margin-bottom: 4px;
            /* approx Seton et al.: red → yellow → aqua → blue → violet → dark purple */
            background: linear-gradient(to right,
                    #a4262c,
                    #fcc704,
                    #9adbb8,
                    #176fc1,
                    #420186,
                    #5c007d);
        }

        #lineModeButton {
            position: fixed;
            top: 8px;
            right: 10px;
            padding: 4px 10px;
            font-size: 13px;
            border-radius: 4px;
            border: 1px solid #888;
            background: #222;
            color: #fff;
            cursor: pointer;
        }

        #lineModeButton.active {
            background: #444;
            border-color: #fff;
        }

        #citation {
            position: fixed;
            left: 10px;
            bottom: 10px;
            max-width: 40vw;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            font-size: 11px;
            border-radius: 4px;
            line-height: 1.3;
        }

        #citation a {
            color: #aad7ff;
            text-decoration: none;
        }

        #citation a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div id="container">
        <canvas id="ageCanvas"></canvas>

        <div id="legend">
            <div id="legendBar"></div>
            <div>Young &larr; Age of oceanic crust (Myr) &rarr; Old</div>
        </div>
    </div>
    <div id="instructions"></div>

    <div id="regionBar">
        <label for="regionSelect">Region:</label>
        <select id="regionSelect">
            <option value="SAtl">South Atlantic</option>
            <option value="NAtl">North Atlantic</option>
            <option value="WNAmer">Western North America</option>
            <option value="WSAmer">Western South America</option>
            <option value="Hawaii">Hawaiian Region</option>
            <option value="Mariana">Japan/Mariana Region</option>
            <option value="Tonga">Tonga Region</option>
        </select>
    </div>

    <div id="info">Loading data…</div>

    <button id="lineModeButton" type="button">Line mode</button>

    <div id="citation">
        Data:
        <a href="https://www.earthbyte.org/a-global-dataset-of-present-day-oceanic-crustal-age-and-seafloor-spreading-parameters/"
            target="_blank" rel="noopener noreferrer">EarthByte</a>
        Coasts from <a href="https://www.naturalearthdata.com/downloads/110m-physical-vectors/110m-coastline/"
            target="_blank" rel="noopener noreferrer">Natural Earth</a>.
    </div>

    <script>
        const canvas = document.getElementById("ageCanvas");
        const ctx = canvas.getContext("2d");
        const info = document.getElementById("info");
        const instructions = document.getElementById("instructions");
        const lineModeButton = document.getElementById("lineModeButton");
        const regionSelect = document.getElementById("regionSelect");

        instructions.textContent = "Press E or tap 'Line mode' to enter Line-Drawing Mode";

        let coast = null;  // coastline polylines
        let coast10m = null; // 10m minor islands

        // region -> JSON file
        const REGION_FILES = {
            SAtl: "age_SAtl_6m.json",
            NAtl: "age_NAtl_6m.json",
            WNAmer: "age_WNAmer_6m.json",
            WSAmer: "age_WSAmer_6m.json",
            Hawaii: "age_Hawaii_6m.json",
            Mariana: "age_Mariana_6m.json",
            Tonga: "age_Tonga_6m.json",
        };

        let grid = null;  // {lon, lat, data, units, ...}

        let lineMode = false;
        let isDraggingLine = false;
        let lineStart = null;
        let lineEnd = null;
        let tickCount = 8;

        const mapCanvas = document.createElement("canvas");
        const mapCtx = mapCanvas.getContext("2d");

        function loadCoastlines() {
            // 110m main coastlines
            fetch("coastlines_110m.json")
                .then(r => r.json())
                .then(data => {
                    coastMain = data;
                    redraw();   // draw if grid is already loaded
                })
                .catch(err => {
                    console.error("Error loading coastlines_110m.json", err);
                });

            // 10m minor islands
            fetch("ne_10m_coastline.json")
                .then(r => r.json())
                .then(data => {
                    coast10m = data;
                    redraw();
                })
                .catch(err => {
                    console.error("Error loading ne_10m_coastline.json", err);
                });
        }


        function loadRegion(key) {
            const file = REGION_FILES[key];
            if (!file) return;

            info.textContent = "Loading data…";
            instructions.textContent = "Press E or tap 'Line mode' to enter Line-Drawing Mode";

            // reset line state
            lineMode = false;
            isDraggingLine = false;
            lineStart = null;
            lineEnd = null;
            tickCount = 8;
            lineModeButton.classList.remove("active");

            fetch(file)
                .then(r => r.json())
                .then(data => {
                    grid = data;

                    const lons = grid.lon;
                    const lats = grid.lat;
                    grid.lonMin = Math.min(...lons);
                    grid.lonMax = Math.max(...lons);
                    grid.latMin = Math.min(...lats);
                    grid.latMax = Math.max(...lats);
                    grid.latIncreasing = lats[0] < lats[lats.length - 1];

                    resizeCanvas();
                    info.textContent = "Move cursor or touch to read age values";
                })
                .catch(err => {
                    console.error(err);
                    info.textContent = "Error loading " + file;
                });
        }

        function resizeCanvas() {
            if (!grid) return;

            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width;
            canvas.height = rect.height;

            mapCanvas.width = grid.lon.length;
            mapCanvas.height = grid.lat.length;

            renderMapToOffscreen();
            redraw();
        }

        function renderMapToOffscreen() {
            if (!grid) return;

            const data = grid.data;
            const width = mapCanvas.width;
            const height = mapCanvas.height;

            mapCtx.clearRect(0, 0, width, height);
            mapCtx.imageSmoothingEnabled = false;

            const maxAge = estimateMaxFinite(data, 200);

            for (let j = 0; j < height; j++) {
                const row = data[j];
                const y = grid.latIncreasing ? (height - 1 - j) : j;

                for (let i = 0; i < width; i++) {
                    const age = row[i];
                    if (age === null || isNaN(age)) continue;

                    mapCtx.fillStyle = ageToColor(age);
                    mapCtx.fillRect(i, y, 1, 1);
                }
            }
        }

        function redraw() {
            const width = canvas.width;
            const height = canvas.height;

            ctx.clearRect(0, 0, width, height);
            ctx.imageSmoothingEnabled = true;
            ctx.drawImage(mapCanvas, 0, 0, width, height);

            drawCoastlines();        // <-- new overlay

            if (lineStart && lineEnd) {
                drawLineWithTicks();   // line + ticks stays on top of everything
            }
        }

        function drawLineWithTicks() {
            if (!lineStart || !lineEnd) return;

            const x1 = lineStart.x;
            const y1 = lineStart.y;
            const x2 = lineEnd.x;
            const y2 = lineEnd.y;

            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.hypot(dx, dy) || 1;

            const nx = -dy / length;
            const ny = dx / length;
            const halfTick = 6;

            ctx.save();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            const n = Math.max(tickCount, 2);
            const steps = n - 1;

            for (let k = 0; k < n; k++) {
                const t = steps === 0 ? 0.5 : k / steps;
                const px = x1 + dx * t;
                const py = y1 + dy * t;

                ctx.beginPath();
                ctx.moveTo(px - nx * halfTick, py - ny * halfTick);
                ctx.lineTo(px + nx * halfTick, py + ny * halfTick);
                ctx.stroke();
            }

            ctx.restore();
        }

        function estimateMaxFinite(data, defaultMax) {
            let max = 0;
            for (let j = 0; j < data.length; j++) {
                const row = data[j];
                for (let i = 0; i < row.length; i++) {
                    const v = row[i];
                    if (v != null && isFinite(v) && v > max) max = v;
                }
            }
            return max || defaultMax;
        }

        // Approximate Seton et al. (2020) colour scale
        // 0 Myr = red, ~40 = yellow, ~90 = aqua, ~130 = blue, >~200 = purple
        const MAX_AGE_FOR_COLOR = 340;  // clamp here

        const COLOR_STOPS = [
            { t: 0.00, r: 164, g: 38, b: 44 }, // young ridge: deep red
            { t: 0.15, r: 252, g: 199, b: 4 }, // orange-yellow
            { t: 0.35, r: 154, g: 219, b: 184 }, // light aqua
            { t: 0.50, r: 23, g: 111, b: 193 }, // blue
            { t: 0.70, r: 66, g: 1, b: 134 }, // violet
            { t: 1.00, r: 92, g: 0, b: 125 }, // dark purple (oldest)
        ];

        function ageToColor(age) {
            if (!isFinite(age) || age < 0) {
                return "rgba(0,0,0,0)";
            }

            // normalise age to 0–1 using a fixed max
            const tRaw = age / MAX_AGE_FOR_COLOR;
            const t = Math.max(0, Math.min(tRaw, 1));

            // find segment [s0, s1] with s0.t <= t <= s1.t
            let s0 = COLOR_STOPS[0];
            for (let i = 1; i < COLOR_STOPS.length; i++) {
                const s1 = COLOR_STOPS[i];
                if (t <= s1.t) {
                    const u = (t - s0.t) / (s1.t - s0.t);
                    const r = Math.round(s0.r + u * (s1.r - s0.r));
                    const g = Math.round(s0.g + u * (s1.g - s0.g));
                    const b = Math.round(s0.b + u * (s1.b - s0.b));
                    return `rgb(${r},${g},${b})`;
                }
                s0 = s1;
            }

            const last = COLOR_STOPS[COLOR_STOPS.length - 1];
            return `rgb(${last.r},${last.g},${last.b})`;
        }


        function drawCoastlines() {
            // main 110m coastlines
            //drawCoastlineSet(coastMain, 1.2, "white", 0.9);

            // 10m coastline on top (slightly thinner)
            drawCoastlineSet(coast10m, 1.0, "white", 0.9);
        }

        function drawCoastlineSet(coastData, lineWidth, strokeStyle, alpha) {
            if (!grid || !coastData || !coastData.features) return;

            const width = canvas.width;
            const height = canvas.height;

            const lonMin = grid.lonMin;
            const lonMax = grid.lonMax;
            const latMin = grid.latMin;
            const latMax = grid.latMax;

            ctx.save();
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = strokeStyle;
            ctx.globalAlpha = alpha;

            for (const feature of coastData.features) {
                const lines = feature.lines;
                if (!lines) continue;

                for (const line of lines) {
                    if (!line || line.length < 2) continue;

                    ctx.beginPath();
                    let first = true;

                    for (const [lon, lat] of line) {
                        const x = (lon - lonMin) / (lonMax - lonMin) * width;
                        const y = (latMax - lat) / (latMax - latMin) * height;

                        if (first) {
                            ctx.moveTo(x, y);
                            first = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }

                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        function handleMouseMove(e) {
            if (!grid) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const lonMin = grid.lonMin;
            const lonMax = grid.lonMax;
            const latMin = grid.latMin;
            const latMax = grid.latMax;

            const lon = lonMin + (x / rect.width) * (lonMax - lonMin);
            const lat = latMax - (y / rect.height) * (latMax - latMin);

            const i = nearestIndex(grid.lon, lon);
            const j = nearestIndex(grid.lat, lat);
            const age = grid.data[j][i];

            const units = grid.units || "Myr";
            const ageText =
                age == null || !isFinite(age) ? "no data" : age.toFixed(1) + " " + units;

            info.textContent =
                "Longitude " + lon.toFixed(1) +
                "° | Age: " + ageText;
        }

        canvas.addEventListener("mousedown", (e) => {
            if (!lineMode) return;
            isDraggingLine = true;
            const { x, y } = getCanvasCoords(e);
            lineStart = { x, y };
            lineEnd = { x, y };
        });

        canvas.addEventListener("mousemove", (e) => {
            if (!lineMode || !isDraggingLine) {
                handleMouseMove(e);
            }

            if (lineMode && isDraggingLine) {
                const { x, y } = getCanvasCoords(e);
                lineEnd = { x, y };
                redraw();
            }
        });

        canvas.addEventListener("mouseup", (e) => {
            if (!lineMode || !isDraggingLine) return;
            isDraggingLine = false;
            const { x, y } = getCanvasCoords(e);
            lineEnd = { x, y };
            instructions.textContent =
                "Press ↑/↓ to change tick resolution (desktop)";
            redraw();
        });

        canvas.addEventListener("mouseleave", () => {
            isDraggingLine = false;
        });

        // touch: tap for age, drag for line
        canvas.addEventListener("touchstart", (e) => {
            if (!grid) return;
            const touch = e.touches[0];
            if (!touch) return;

            if (lineMode) {
                isDraggingLine = true;
                const { x, y } = getCanvasCoords(touch);
                lineStart = { x, y };
                lineEnd = { x, y };
                redraw();
            } else {
                handleMouseMove(touch);
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener("touchmove", (e) => {
            const touch = e.touches[0];
            if (!touch) return;

            if (lineMode && isDraggingLine) {
                const { x, y } = getCanvasCoords(touch);
                lineEnd = { x, y };
                redraw();
            } else {
                handleMouseMove(touch);
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener("touchend", (e) => {
            if (lineMode && isDraggingLine) {
                const touch = e.changedTouches[0];
                if (touch) {
                    const { x, y } = getCanvasCoords(touch);
                    lineEnd = { x, y };
                }
                isDraggingLine = false;
                instructions.textContent =
                    "Use ↑/↓ (desktop) to change tick resolution";
                redraw();
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener("touchcancel", (e) => {
            isDraggingLine = false;
            e.preventDefault();
        }, { passive: false });

        // keyboard: E and arrows
        window.addEventListener("keydown", (e) => {
            if (e.key === "e" || e.key === "E") {
                lineMode = true;
                lineModeButton.classList.add("active");
                instructions.textContent = "Click or touch and drag to draw a line across the Atlantic";
                e.preventDefault();
                return;
            }

            if (!lineMode) return;
            if (!lineStart || !lineEnd) return;

            if (e.key === "ArrowUp") {
                tickCount = Math.min(tickCount + 1, 100);
                e.preventDefault();
            } else if (e.key === "ArrowDown") {
                tickCount = Math.max(tickCount - 1, 2);
                e.preventDefault();
            } else {
                return;
            }

            instructions.textContent =
                "Tick marks: " + tickCount +
                "  |  Use ↑/↓ to change resolution (desktop)";
            redraw();
        });

        lineModeButton.addEventListener("click", () => {
            lineMode = true;
            lineModeButton.classList.add("active");
            instructions.textContent = "Click or touch and drag to draw a line across the Atlantic";
        });

        regionSelect.addEventListener("change", (e) => {
            loadRegion(e.target.value);
        });

        window.addEventListener("resize", resizeCanvas);

        function nearestIndex(arr, value) {
            let best = 0;
            let bestDiff = Math.abs(arr[0] - value);
            for (let k = 1; k < arr.length; k++) {
                const diff = Math.abs(arr[k] - value);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    best = k;
                }
            }
            return best;
        }

        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        // initial load: South Atlantic
        loadCoastlines();
        loadRegion("SAtl");
    </script>
</body>

</html>