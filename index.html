<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Seafloor Age – Interactive Viewer</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: #000;
        }

        body {
            font-family: system-ui, sans-serif;
            color: #fff;
        }

        #container {
            position: relative;
            width: min(90vw, 1200px);
            aspect-ratio: 90 / 80;
            margin: 20px auto;
        }

        #ageCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #111;
            cursor: crosshair;
        }

        /* overlays pinned to viewport */

        #instructions {
            position: fixed;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 13px;
            pointer-events: none;
            white-space: nowrap;
            z-index: 5;
        }

        /* region selector, under instructions */
        #regionBar {
            position: fixed;
            top: 34px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 4px;
            z-index: 5;
        }

        #regionBar select {
            font-size: 13px;
            background: #222;
            color: #fff;
            border-radius: 4px;
            border: 1px solid #555;
            padding: 2px 6px;
        }

        #showLatLabel {
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 2px;
            margin-left: 6px;
        }

        #showLatCheckbox {
            accent-color: #ccc;
        }

        #info {
            position: fixed;
            /* stick to viewport, but we move it in JS */
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            font-size: 13px;
            border-radius: 4px;
            pointer-events: none;
            white-space: nowrap;
            z-index: 5;
        }

        #info .label {
            color: #aaaaaa;
        }

        #info .value {
            font-weight: 600;
            font-size: 15px;
        }

        /* Legend now fixed to viewport, always visible */

        #legend {
            position: fixed;
            right: 10px;
            bottom: 10px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            font-size: 12px;
            border-radius: 4px;
            z-index: 5;
        }

        #legendBar {
            width: 200px;
            height: 12px;
            margin-bottom: 4px;
            /* approx Seton et al.: red → yellow → aqua → blue → violet → dark purple */
            background: linear-gradient(to right,
                    #a4262c,
                    #fcc704,
                    #9adbb8,
                    #176fc1,
                    #420186,
                    #5c007d);
        }

        #lineModeButton {
            position: fixed;
            top: 8px;
            right: 10px;
            padding: 4px 10px;
            font-size: 13px;
            border-radius: 4px;
            border: 1px solid #888;
            background: #222;
            color: #fff;
            cursor: pointer;
            z-index: 5;
        }

        #lineModeButton.active {
            background: #444;
            border-color: #fff;
        }

        #citation {
            position: fixed;
            left: 10px;
            bottom: 45px;
            max-width: 40vw;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            font-size: 11px;
            border-radius: 4px;
            line-height: 1.3;
            z-index: 5;
        }

        #citation a {
            color: #aad7ff;
            text-decoration: none;
        }

        #citation a:hover {
            text-decoration: underline;
        }

        /* Scroll hint */

        #scrollHint {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 10px;
            background: rgba(0, 0, 0, 0.65);
            color: #fff;
            font-size: 11px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 4;
            display: none;
        }

        #scrollHint .arrow {
            display: inline-block;
            margin-right: 4px;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(4px);
            }
        }
    </style>
</head>

<body>
    <div id="container">
        <canvas id="ageCanvas"></canvas>
    </div>

    <!-- Legend now outside container, fixed -->
    <div id="legend">
        <div id="legendBar"></div>
        <div>Young &larr; Age of oceanic crust (Myr) &rarr; Old</div>
    </div>

    <div id="instructions"></div>

    <div id="regionBar">
        <label for="regionSelect">Region:</label>
        <select id="regionSelect">
            <option value="SAtl">South Atlantic</option>
            <option value="NAtl">North Atlantic</option>
            <option value="WNAmer">Western North America</option>
            <option value="WSAmer">Western South America</option>
            <option value="Hawaii">Hawaiian Region</option>
            <option value="Mariana">Japan/Mariana Region</option>
            <option value="Tonga">Tonga Region</option>
        </select>

        <label id="showLatLabel">
            <input type="checkbox" id="showLatCheckbox">
            show latitude in data
        </label>
    </div>

    <div id="info">Loading data…</div>

    <button id="lineModeButton" type="button">Line mode</button>

    <div id="citation">
        Data:
        <a href="https://www.earthbyte.org/a-global-dataset-of-present-day-oceanic-crustal-age-and-seafloor-spreading-parameters/"
            target="_blank" rel="noopener noreferrer">EarthByte</a>
        Coasts from
        <a href="https://www.naturalearthdata.com" target="_blank" rel="noopener noreferrer">Natural Earth</a>.
    </div>

    <div id="scrollHint">
        <span class="arrow">▼</span>Scroll to see full map
    </div>

    <script>
        const canvas = document.getElementById("ageCanvas");
        const ctx = canvas.getContext("2d");
        const info = document.getElementById("info");
        const instructions = document.getElementById("instructions");
        const lineModeButton = document.getElementById("lineModeButton");
        const regionSelect = document.getElementById("regionSelect");
        const showLatCheckbox = document.getElementById("showLatCheckbox");
        const scrollHint = document.getElementById("scrollHint");

        instructions.textContent = "Press E or tap 'Line mode' to enter Line-Drawing Mode";

        // Fix coastline variables: main + 10m
        let coastMain = null;   // 110m global coastlines
        let coast10m = null;    // 10m coastline

        // region -> JSON file
        const REGION_FILES = {
            SAtl: "age_SAtl_6m.json",
            NAtl: "age_NAtl_6m.json",
            WNAmer: "age_WNAmer_6m.json",
            WSAmer: "age_WSAmer_6m.json",
            Hawaii: "age_Hawaii_6m.json",
            Mariana: "age_Mariana_6m.json",
            Tonga: "age_Tonga_6m.json",
        };

        let grid = null;  // {lon, lat, data, units, ...}

        let lineMode = false;
        let isDraggingLine = false;
        let lineStart = null;
        let lineEnd = null;
        let tickCount = 8;

        const mapCanvas = document.createElement("canvas");
        const mapCtx = mapCanvas.getContext("2d");

        const INSTR_ENTER = "Press E or tap 'Line mode' to enter Line-Drawing Mode";
        const INSTR_LINE = "Line mode: drag to draw a line (tap button again to exit)";
        const INSTR_READ = "Move cursor or touch to read age values";

        function setLineMode(on) {
            lineMode = !!on;

            // stop any in-progress drag when switching modes
            isDraggingLine = false;

            // UI state
            lineModeButton.classList.toggle("active", lineMode);

            // Instructions
            instructions.textContent = lineMode ? INSTR_LINE : INSTR_READ;
        }

        function loadCoastlines() {
            // 110m main coastlines
            fetch("coastlines_110m.json")
                .then(r => r.json())
                .then(data => {
                    coastMain = data;
                    redraw();   // draw if grid is already loaded
                })
                .catch(err => {
                    console.error("Error loading coastlines_110m.json", err);
                });

            // 10m coastline
            fetch("ne_10m_coastline.json")
                .then(r => r.json())
                .then(data => {
                    coast10m = data;
                    redraw();
                })
                .catch(err => {
                    console.error("Error loading ne_10m_coastline.json", err);
                });
        }

        function loadRegion(key) {
            const file = REGION_FILES[key];
            if (!file) return;

            info.textContent = "Loading data…";

            // reset line state
            setLineMode(false);
            lineStart = null;
            lineEnd = null;
            tickCount = 8;

            fetch(file)
                .then(r => r.json())
                .then(data => {
                    grid = data;

                    const lons = grid.lon;
                    const lats = grid.lat;
                    grid.lonMin = Math.min(...lons);
                    grid.lonMax = Math.max(...lons);
                    grid.latMin = Math.min(...lats);
                    grid.latMax = Math.max(...lats);
                    grid.latIncreasing = lats[0] < lats[lats.length - 1];

                    resizeCanvas();
                    info.textContent = "Move cursor or touch to read age values";
                    updateScrollHint();
                })
                .catch(err => {
                    console.error(err);
                    info.textContent = "Error loading " + file;
                });
        }

        function resizeCanvas() {
            if (!grid) return;

            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width;
            canvas.height = rect.height;

            mapCanvas.width = grid.lon.length;
            mapCanvas.height = grid.lat.length;

            renderMapToOffscreen();
            redraw();
            updateScrollHint();
        }

        function renderMapToOffscreen() {
            if (!grid) return;

            const data = grid.data;
            const width = mapCanvas.width;
            const height = mapCanvas.height;

            mapCtx.clearRect(0, 0, width, height);
            mapCtx.imageSmoothingEnabled = false;

            for (let j = 0; j < height; j++) {
                const row = data[j];
                const y = grid.latIncreasing ? (height - 1 - j) : j;

                for (let i = 0; i < width; i++) {
                    const age = row[i];
                    if (age === null || isNaN(age)) continue;

                    mapCtx.fillStyle = ageToColor(age);
                    mapCtx.fillRect(i, y, 1, 1);
                }
            }
        }

        function redraw() {
            const width = canvas.width;
            const height = canvas.height;

            ctx.clearRect(0, 0, width, height);
            ctx.imageSmoothingEnabled = true;
            ctx.drawImage(mapCanvas, 0, 0, width, height);

            drawCoastlines();

            if (lineStart && lineEnd) {
                drawLineWithTicks();
            }
        }

        function drawLineWithTicks() {
            if (!lineStart || !lineEnd) return;

            const x1 = lineStart.x;
            const y1 = lineStart.y;
            const x2 = lineEnd.x;
            const y2 = lineEnd.y;

            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.hypot(dx, dy) || 1;

            const nx = -dy / length;
            const ny = dx / length;
            const halfTick = 6;

            ctx.save();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            const n = Math.max(tickCount, 2);
            const steps = n - 1;

            for (let k = 0; k < n; k++) {
                const t = steps === 0 ? 0.5 : k / steps;
                const px = x1 + dx * t;
                const py = y1 + dy * t;

                ctx.beginPath();
                ctx.moveTo(px - nx * halfTick, py - ny * halfTick);
                ctx.lineTo(px + nx * halfTick, py + ny * halfTick);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Approximate Seton et al. (2020) colour scale
        const MAX_AGE_FOR_COLOR = 340;  // clamp here
        const COLOR_STOPS = [
            { t: 0.00, r: 164, g: 38, b: 44 },
            { t: 0.15, r: 252, g: 199, b: 4 },
            { t: 0.35, r: 154, g: 219, b: 184 },
            { t: 0.50, r: 23, g: 111, b: 193 },
            { t: 0.70, r: 66, g: 1, b: 134 },
            { t: 1.00, r: 92, g: 0, b: 125 },
        ];

        function ageToColor(age) {
            if (!isFinite(age) || age < 0) {
                return "rgba(0,0,0,0)";
            }

            const tRaw = age / MAX_AGE_FOR_COLOR;
            const t = Math.max(0, Math.min(tRaw, 1));

            let s0 = COLOR_STOPS[0];
            for (let i = 1; i < COLOR_STOPS.length; i++) {
                const s1 = COLOR_STOPS[i];
                if (t <= s1.t) {
                    const u = (t - s0.t) / (s1.t - s0.t);
                    const r = Math.round(s0.r + u * (s1.r - s0.r));
                    const g = Math.round(s0.g + u * (s1.g - s0.g));
                    const b = Math.round(s0.b + u * (s1.b - s0.b));
                    return `rgb(${r},${g},${b})`;
                }
                s0 = s1;
            }
            const last = COLOR_STOPS[COLOR_STOPS.length - 1];
            return `rgb(${last.r},${last.g},${last.b})`;
        }

        function drawCoastlines() {
            // main 110m coastlines
            //drawCoastlineSet(coastMain, 1.2, "white", 0.9);
            // 10m coastline on top (slightly thinner)
            drawCoastlineSet(coast10m, 1.0, "white", 0.9);
        }

        function drawCoastlineSet(coastData, lineWidth, strokeStyle, alpha) {
            if (!grid || !coastData || !coastData.features) return;

            const width = canvas.width;
            const height = canvas.height;

            const lonMin = grid.lonMin;
            const lonMax = grid.lonMax;
            const latMin = grid.latMin;
            const latMax = grid.latMax;

            ctx.save();
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = strokeStyle;
            ctx.globalAlpha = alpha;

            for (const feature of coastData.features) {
                const lines = feature.lines;
                if (!lines) continue;

                for (const line of lines) {
                    if (!line || line.length < 2) continue;

                    ctx.beginPath();
                    let first = true;

                    for (const [lon, lat] of line) {
                        const x = (lon - lonMin) / (lonMax - lonMin) * width;
                        const y = (latMax - lat) / (latMax - latMin) * height;

                        if (first) {
                            ctx.moveTo(x, y);
                            first = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        function handleMouseMove(e) {
            if (!grid) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const lonMin = grid.lonMin;
            const lonMax = grid.lonMax;
            const latMin = grid.latMin;
            const latMax = grid.latMax;

            const lon = lonMin + (x / rect.width) * (lonMax - lonMin);
            const lat = latMax - (y / rect.height) * (latMax - latMin);

            const i = nearestIndex(grid.lon, lon);
            const j = nearestIndex(grid.lat, lat);
            const age = grid.data[j][i];

            const units = grid.units || "Myr";
            const ageText =
                age == null || !isFinite(age) ? "no data" : age.toFixed(1) + " " + units;

            const showLat = showLatCheckbox && showLatCheckbox.checked;

            let html =
                `<span class="label">Longitude:</span> <span class="value">${lon.toFixed(1)}°</span>`;
            if (showLat) {
                html +=
                    ` &nbsp; <span class="label">Lat:</span> <span class="value">${lat.toFixed(1)}°</span>`;
            }
            html += `<br><span class="label">Age:</span> <span class="value">${ageText}</span>`;

            info.innerHTML = html;

            // Position the info box near the cursor/touch, staying on-screen
            const offset = 12; // pixels away from cursor
            let left = e.clientX + offset;
            let top = e.clientY + offset;

            const infoRect = info.getBoundingClientRect();
            const maxLeft = window.innerWidth - infoRect.width - 8;
            const maxTop = window.innerHeight - infoRect.height - 8;

            if (left > maxLeft) {
                left = e.clientX - infoRect.width - offset;
            }
            if (top > maxTop) {
                top = e.clientY - infoRect.height - offset;
            }

            info.style.left = `${left}px`;
            info.style.top = `${top}px`;
        }

        canvas.addEventListener("mousedown", (e) => {
            if (!lineMode) return;
            isDraggingLine = true;
            const { x, y } = getCanvasCoords(e);
            lineStart = { x, y };
            lineEnd = { x, y };
        });

        canvas.addEventListener("mousemove", (e) => {
            if (!lineMode || !isDraggingLine) {
                handleMouseMove(e);
            }

            if (lineMode && isDraggingLine) {
                const { x, y } = getCanvasCoords(e);
                lineEnd = { x, y };
                redraw();
            }
        });

        canvas.addEventListener("mouseup", (e) => {
            if (!lineMode || !isDraggingLine) return;
            isDraggingLine = false;
            const { x, y } = getCanvasCoords(e);
            lineEnd = { x, y };
            if (lineMode) instructions.textContent = "Press ↑/↓ to change tick resolution (desktop)";

            redraw();
        });

        canvas.addEventListener("mouseleave", () => {
            isDraggingLine = false;
        });

        // touch: tap for age, drag for line
        canvas.addEventListener("touchstart", (e) => {
            if (!grid) return;
            const touch = e.touches[0];
            if (!touch) return;

            if (lineMode) {
                isDraggingLine = true;
                const { x, y } = getCanvasCoords(touch);
                lineStart = { x, y };
                lineEnd = { x, y };
                redraw();
            } else {
                handleMouseMove(touch);
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener("touchmove", (e) => {
            const touch = e.touches[0];
            if (!touch) return;

            if (lineMode && isDraggingLine) {
                const { x, y } = getCanvasCoords(touch);
                lineEnd = { x, y };
                redraw();
            } else {
                handleMouseMove(touch);
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener("touchend", (e) => {
            if (lineMode && isDraggingLine) {
                const touch = e.changedTouches[0];
                if (touch) {
                    const { x, y } = getCanvasCoords(touch);
                    lineEnd = { x, y };
                }
                isDraggingLine = false;
                if (lineMode) instructions.textContent = "Use ↑/↓ (desktop) to change tick resolution";

                redraw();
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener("touchcancel", (e) => {
            isDraggingLine = false;
            e.preventDefault();
        }, { passive: false });

        // keyboard: E and arrows
        window.addEventListener("keydown", (e) => {
            if (e.key === "e" || e.key === "E") {
                setLineMode(!lineMode);
                e.preventDefault();
                return;
            }

            if (!lineMode) return;
            if (!lineStart || !lineEnd) return;

            if (e.key === "ArrowUp") {
                tickCount = Math.min(tickCount + 1, 100);
                e.preventDefault();
            } else if (e.key === "ArrowDown") {
                tickCount = Math.max(tickCount - 1, 2);
                e.preventDefault();
            } else {
                return;
            }

            instructions.textContent =
                "Tick marks: " + tickCount +
                "  |  Use ↑/↓ to change resolution (desktop)";
            redraw();
        });

        lineModeButton.addEventListener("click", () => {
            setLineMode(!lineMode);
        });

        regionSelect.addEventListener("change", (e) => {
            loadRegion(e.target.value);
        });

        window.addEventListener("resize", resizeCanvas);
        window.addEventListener("resize", updateScrollHint);

        window.addEventListener("scroll", () => {
            if (!scrollHint) return;
            if (window.scrollY > 10) {
                scrollHint.style.display = "none";
            }
        });

        function nearestIndex(arr, value) {
            let best = 0;
            let bestDiff = Math.abs(arr[0] - value);
            for (let k = 1; k < arr.length; k++) {
                const diff = Math.abs(arr[k] - value);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    best = k;
                }
            }
            return best;
        }

        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function updateScrollHint() {
            if (!scrollHint) return;
            const scrollable =
                document.documentElement.scrollHeight > window.innerHeight + 4;
            scrollHint.style.display = scrollable ? "block" : "none";
        }

        // initial load: South Atlantic
        loadCoastlines();
        loadRegion("SAtl");
    </script>
</body>

</html>